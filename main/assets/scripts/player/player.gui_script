local energy_scale = nil
local energy_count = nil
local energy_scale_damage = nil
local max_energy_scale = nil
math.randomseed(os.time())

--Инициализация монет в начале игры
local function set_coins(self,coins)
	self.coins = coins
	gui.set_text(gui.get_node('coins_count'), coins)
end

--Добавление монет при уничтожении противника
local function add_coins(self,coins)
	local temp_current_coins = self.coins
	self.coins = self.coins + coins
	self.add_coins = timer.delay(0.003, true, function() 
		if self.coins > temp_current_coins then
			temp_current_coins = temp_current_coins + 1
			gui.set_text(gui.get_node('coins_count'), temp_current_coins)
		else
			timer.cancel(self.add_coins)
		end
	end)
end

--Инициализация начального здоровья
local function set_health(self,health)
	self.max_health = health
	self.health = health
	gui.set_text(gui.get_node('health_count'), self.health..'/'..self.max_health)
end

--Инициализация начального урона
local function set_damage(self,damage)
	self.damage = damage
	gui.set_text(gui.get_node('damage_count'), self.damage)
end

local function add_potion(self)
	gui.set(gui.get_node('potion'), 'color.w', 1)
	gui.set(gui.get_node('potion_count'), 'color.w', 1)
	self.potions = self.potions + 1
	gui.set_text(gui.get_node('potion_count'), self.potions)
end

local function use_potion(self) 
	if self.health < self.max_health and self.potions > 0 then
		gui.set(gui.get_node('screen_health'), 'color.w', 0.6)
		gui.animate(gui.get_node('screen_health'), 'color.w', 0, gui.EASING_LINEAR, 0.3)
		self.potions = self.potions - 1
		gui.set_text(gui.get_node('potion_count'), self.potions)
		self.health = self.max_health
		gui.set_text(gui.get_node('health_count'), self.health..'/'..self.max_health)
	end

	if self.potions == 0 then
		gui.set(gui.get_node('potion'), 'color.w', 0.5)
		gui.set(gui.get_node('potion_count'), 'color.w', 0.5)
	end

end

--Инициализация начальной выносливости
local function set_energy(self,energy)
	self.max_energy = energy
	self.energy = energy
	gui.set_text(gui.get_node('energy_count'), self.energy..'/'..self.max_energy)
end

local function take_energy(self,energy)
	if energy_scale_damage == nil then
		energy_count = self.max_energy / 10
		energy_scale_damage =  energy_scale / energy_count
	end 

	
	self.energy = self.energy - energy
	if self.energy <=0 then
		self.energy = 0
		msg.post(self.enemy, 'not_energy')
		msg.post('#', 'add_energy')
		
	end
	
	energy_scale = energy_scale - energy_scale_damage
	print(energy_scale)
	gui.set(gui.get_node('yellow_rect'), 'scale.x',energy_scale)
	
	gui.set_text(gui.get_node('energy_count'), self.energy..'/'..self.max_energy)
end

local function take_damage(self,enemy_damage)
	local damage_type = self.damage_types[math.random(1,#self.damage_types)]
	local pos_y = gui.get(gui.get_node('enemy_damage'), 'position.y')
	if damage_type == 'miss' then
		gui.set_text(gui.get_node('enemy_damage'),'Промах')
		gui.set_color(gui.get_node('enemy_damage'),vmath.vector4(1,1,1,0))
		gui.animate(gui.get_node('enemy_damage'), 'color.w', 0, gui.EASING_LINEAR, 1)
		gui.animate(gui.get_node('enemy_damage'), 'position.y', pos_y + 5, gui.EASING_LINEAR, 1)
		timer.delay(1.5, false, function() gui.set(gui.get_node('enemy_damage'), 'position.y', pos_y) end)
		gui.set(gui.get_node('enemy_damage'), 'color.w', 1)
	elseif damage_type == 'damage' then
		gui.set(gui.get_node('screen_damage'), 'color.w', 0.6)
		gui.animate(gui.get_node('screen_damage'), 'color.w', 0, gui.EASING_LINEAR, 0.3)
		gui.set_color(gui.get_node('enemy_damage'),vmath.vector4(1,1,1,0))
		self.health = self.health - enemy_damage
		gui.set_text(gui.get_node('enemy_damage'), '-'..enemy_damage)
		gui.animate(gui.get_node('enemy_damage'), 'color.w', 0, gui.EASING_LINEAR, 1)
		gui.animate(gui.get_node('enemy_damage'), 'position.y', pos_y + 5, gui.EASING_LINEAR, 1)
		timer.delay(1.5, false, function() gui.set(gui.get_node('enemy_damage'), 'position.y', pos_y) end)
		gui.set(gui.get_node('enemy_damage'), 'color.w', 1)
	elseif damage_type == 'crit_damage' then
		gui.set_color(gui.get_node('enemy_damage'),vmath.vector4(1,0,0,0))
		gui.set(gui.get_node('screen_damage'), 'color.w', 0.6)
		gui.animate(gui.get_node('screen_damage'), 'color.w', 0, gui.EASING_LINEAR, 0.3)
		self.health = self.health - enemy_damage * 2
		gui.set_text(gui.get_node('enemy_damage'), '-'..enemy_damage * 2)
		gui.animate(gui.get_node('enemy_damage'), 'color.w', 0, gui.EASING_LINEAR, 1)
		gui.animate(gui.get_node('enemy_damage'), 'position.y', pos_y + 5, gui.EASING_LINEAR, 1)
		timer.delay(1.5, false, function() gui.set(gui.get_node('enemy_damage'), 'position.y', pos_y) end)
		gui.set(gui.get_node('enemy_damage'), 'color.w', 1)
	end
	
	if self.health <= 0 then
		self.health = 0
		msg.post('/game_manager#game_manager', 'end_game')
	end
	gui.set_text(gui.get_node('health_count'), self.health..'/'..self.max_health)
end

function init(self)
	msg.post('.', 'acquire_input_focus')
	self.coins = 0
	self.max_health = 0
	self.health = 0
	self.damage = 0
	self.max_energy = 0
	self.energy = 0
	self.potions = 3
	gui.set_text(gui.get_node('potion_count'), self.potions)
	max_energy_scale = gui.get(gui.get_node('black_rect'), 'scale.x')
	energy_scale = gui.get(gui.get_node('yellow_rect'), 'scale.x')
	print(energy_scale)
	print(energy_scale_damage)
	self.enemy = nil
	self.level_of_dungeon = 1
	self.enemies_of_level = 0
	self.current_enemies_of_level = 0
	self.damage_types = {'miss','damage','crit_damage'}
end


function on_message(self, message_id, message, sender)
	if message_id == hash('start_stats') then
		set_coins(self, message.start_coins)
		set_health(self, message.health)
		set_damage(self, message.damage)
		set_energy(self, message.energy)
	end

	if message_id == hash('init_dungeon') then
		self.level_of_dungeon = message.level_of_dungeon
		gui.set_text(gui.get_node('level_dungeon'), 'Уровень подземелья: '..self.level_of_dungeon)
		self.enemies_of_level = message.enemies_in_levels
		self.current_enemies_of_level = self.enemies_of_level
		gui.set_text(gui.get_node('enemies_count'), 'Врагов на уровне: '..self.current_enemies_of_level..'/'..self.enemies_of_level)
	end

	if message_id == hash('send_id_enemy') then
		self.enemy = message.id
	end

	if message_id == hash('add_potion') then
		add_potion(self)
	end

	if message_id == hash('current_enemies_count') then
		self.current_enemies_of_level = message.current_enemies_count
		gui.set_text(gui.get_node('enemies_count'), 'Врагов на уровне: '..self.current_enemies_of_level..'/'..self.enemies_of_level)
	end

	if message_id == hash('add_coins') then
		add_coins(self, message.coins)
	end

	if message_id == hash('player_damage') and self.health > 0 then
		take_damage(self, message.damage)
		
	end
	if message_id == hash('minus_energy') then
		take_energy(self, 10)
	end
	if message_id == hash('add_energy') then
		self.energy_time = timer.delay(0.6, true, function() 
			if energy_scale >= max_energy_scale then
				energy_scale = max_energy_scale
			end
			energy_scale = energy_scale + energy_scale_damage
			print(energy_scale)
			gui.set(gui.get_node('yellow_rect'), 'scale.x',energy_scale)

			gui.set_text(gui.get_node('energy_count'), self.energy..'/'..self.max_energy)
			if self.energy < self.max_energy then
				self.energy = self.energy + 10
			end
			
			gui.set_text(gui.get_node('energy_count'), self.energy..'/'..self.max_energy) 
			if self.energy >= self.max_energy then
				self.energy = self.max_energy
				timer.cancel(self.energy_time)
				
				timer.delay(0.2, false, function() 
					if self.enemy then
						msg.post(self.enemy, 'energy_full')
					end

					
				end)
				
			end   
		end)
		
	end
end

function on_input(self, action_id, action)
	if gui.pick_node(gui.get_node('potion'), action.x, action.y) and action.released and action_id == hash("touch") then
		use_potion(self)
	end


end